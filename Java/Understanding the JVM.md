## 深入理解Java虚拟机
### 参数汇总
`-Xss` 栈容量
`-Xmx` 堆最大 `-Xms` 堆最小

### GC算法
#### 标记清除
分为两个阶段，标记和清除
不足之处： `效率低` `产生不连续的内存碎片`

#### 复制算法
大内存分为两块大小相等的内存
不足之处`实现简单，运行高效`
IBM研究表明，新生代中对象`98%`都是朝生夕死
Eden | survivor from | survivor to 默认比例 8:1:1
只有`10%`内存会被浪费

#### 标记整理
复制算法在`对象存活率较高`时就需要进行较多的复制操作

#### 分代收集
新生代 老年代 永久代(meta元空间)

### 垃圾收集器
#### CMS收集器
`Concurrent Mark Sweep` 收集器是一种以获取**最短回收停顿时间**为目标的收集齐。
分为四个步骤
- 初始标记
- 并发标记
- 重新标记
- 并发清除
初始标记和重新标记仍然需要`stop the world`
初始标记 就是标记`GC ROOTs`能直接连接到的对象
并发标记 就是不断 Tracing 的过程
重新标记，为了修正并发标记期间因用户运行而产生的变动的记录

**缺点**
- CMS不会导致用户线程停顿，但是占用了一部分CPU资源 默认启动的线程数是 `(CPU数量+3)/4 `,在CPU数量少的机器上资源占用较多，CPU数量越多，影响越小
- 无法处理浮动垃圾，**浮动垃圾**是并发清理阶段产生的新的垃圾，这部分垃圾在标记之后，因此只能下次GC再清理掉
- CMS 是 标记清除，会造成许多内存碎片

#### G1收集器
优点:
- 并发与并行， 在多核场景下，可以利用少部分核心GC, 减少全局`stop the world`的情况发生
- G1 使用的是 标记整理, 是基于`复制`实现的, 不会出现内存碎片
- G1 比 CMS 优点， 可以建立**可预测的停顿时间模型**

G1有一个优先队列，里面的垃圾堆有这样的比较 **回收所获得的空间大小以及回收所使用的时间**,这也是`Garbage First`的由来

有一个`Remembered Set`来避免全堆扫描, 不同Region区，之间有对象的引用的话就放到`Remembered Set`里面，当 枚举GC Roots 进行回收时，有了`Remembered set` 不用扫描全堆也能进行回收

大体步骤
- 初始标记
- 并发标记
- 最终标记
- 筛选回收


#### 内存分配与回收
Minor GC | Major GC | FULL GC
- 新生代GC(Minor GC) 指发生在新生代的垃圾收集动作，Minor GC 非常频繁
- 老年代GC(Major GC/Full GC) 在老年代的GC，伴随着至少一次的Minor GC， `Major GC` 比 `Minor GC` 慢10倍以上

默认15次 Minor GC 晋升到老年代中 ，或者 在`survivor` 空间中相同年龄所有对象大小大于`survivor`空间的一半,可以直接进入老年代

### 线程安全
> 线程安全：当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

## 未看汇总
- 编译优化和运行优化
- G1 & CMS
